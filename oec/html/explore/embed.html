{% extends "templates/base.html" %}

{% block head %}
<link type="text/css" rel="stylesheet" media="all" href="/static/css/libs/d3plus.css" />
<style>
body {
  background: white;
}
#viz{
  display: none;
}
#timeline {
/*  border: red 1px solid;*/
  height: 40px;
}
#timeline button {
  display: none;
  font-size: 15px;
  margin: 4px auto;
}
</style>
{% endblock %}

{% block content %}

<div id="loading"><h1>Loading...</h1></div>
<div id="viz"></div>
<div id="timeline"><button>Click to view more years &raquo;</button></div>

{% endblock %}

{% block js %}

<script src="/static/js/libs/modernizr.custom.js"></script>
<script src="/static/js/libs/d3plus.js"></script>
<script src="/static/js/libs/queue.js"></script>
<script src="/static/js/libs/topojson.js"></script>
<script src="/static/js/d3.brushtimeline.js"></script>

<script>

/* init vars */
var viz = d3plus.viz().container("#viz"),
    attr_id = "{{ current_build.attr_type() }}_id",
    app_type = "{{ current_build.app.type }}",
    attrs = {},
    q = queue()
          .defer(d3.json, "{{ current_build.data_url() }}")
          .defer(d3.json, "{{ current_build.attr_url() }}");

/* general function needed by all apps for making proper nesting and updating
    raw data with changes */
function format_data(error, raw_data, raw_attrs, raw_other){
  
  // set key 'nest' to their id
  raw_attrs.data.forEach(function(d){
    attrs[d.id] = d
  })

  // go through raw data and set each items nest and id vars properly
  raw_data.data.forEach(function(d){
    d.nest = d[attr_id].substr(0, 2)
    d.id = d[attr_id]
  })
  
}

/* to be executed after app has been drawn for first time */
function finish(data, attrs){
  d3.select("#loading")
    .style("display", "none")
    
  d3.select("#viz")
    .style("display", "block")
    .call(viz)
  
  d3.select("#timeline button").style("display", "block")
  
  if(parent.update_text_table){
    parent.update_text_table(data, attrs)
  }
}

/* the ~~BIG KAHUNA~~ 
    for each different type of app we need to initialize our viz slightly
    different so instead of a bunch of if/elses we just have one large switch
    statment. Any gerealized code is put in either the format_data() func or
    the finish() func. */
switch (app_type){
  
  case "tree_map":
    var format_data_orig = format_data
    var go = function(){
      
      format_data_orig.apply(this, arguments);
      raw_data = arguments[1]
      
      viz
        .data(raw_data.data)
        .type("tree_map")
        .attrs(attrs)
        .size("{{ current_build.trade_flow }}_val")
        .id(["nest", "id"])
        .time({"key": "year", "solo": "{{ current_build.year }}" })
        // .time({"key": "year"})
        .depth(1)
        .shape("square")
        .style({"labels": {"align": "start"}})
        .color("color")
        .text({"nest":"name","id":"name"})
        // .title("Tree Map...")
        .title({"total": {"prefix":"Total: "}})
        .height(window.innerHeight - d3.select("#timeline").node().offsetHeight)
      
      finish(raw_data.data, attrs)
    }
    break;
  
  case "stacked":
    var format_data_orig = format_data
    var go = function(){
      
      format_data_orig.apply(this, arguments);
      raw_data = arguments[1]
      
      viz
        .data(raw_data.data)
        .type("stacked")
        .attrs(attrs)
        .id(["nest", "id"])
        .time({"key": "year"})
        .depth(1)
        .shape("area")
        .color("color")
        .x("year")
        .y("{{ current_build.trade_flow }}_val")
        .order("nest")
        .axes({"static":false})
        .text({"nest":"name","id":"name"})
        .height(window.innerHeight - d3.select("#timeline").node().offsetHeight)
        
      finish(raw_data.data, attrs)
    }
    break;
  
  case "network":
    q = q.defer(d3.json, "/static/json/network_{{ current_build.classification }}.json")
    var format_data_orig = format_data
    var go = function(){
      
      format_data_orig.apply(this, arguments);
      raw_data = arguments[1];
      raw_network = arguments[3];
            
      viz
        .data(raw_data.data)
        .attrs(attrs)
        .type("network")
        .id("id")
        .color("color")
        .time("year")
        .nodes(raw_network.nodes)
        .links(raw_network.edges)
        .active({
          "key": function(d){
            return d.export_rca >= 1;
          },
          "spotlight":true
        })
        .height(window.innerHeight - d3.select("#timeline").node().offsetHeight)
      
      finish(raw_data.data, attrs)
    }
    break;
    
  case "geo_map":
    q = q.defer(d3.json, "/static/json/country_coords.json")
    var format_data_orig = format_data
    var go = function(){
      
      format_data_orig.apply(this, arguments);
      raw_data = arguments[1];
      raw_attrs = arguments[2];
      raw_coords = arguments[3];
            
      raw_coords["objects"]["TM_WORLD_BORDERS-0.3"]["geometries"].forEach(function(d){
        country = raw_attrs.data.filter(function(dd){
          return dd.id.substr(2) == d.id.toLowerCase()
        })
        if (country.length) {
          d.id = country[0].id
        }
      })
      
      viz
        .data(raw_data.data)
        .attrs(attrs)
        .type("geo_map")
        .time("year")
        .id("id")
        .color("{{ current_build.trade_flow }}_val")
        .coords(raw_coords)
        .height(window.innerHeight - d3.select("#timeline").node().offsetHeight)
        .time({"solo": ["2010"]})
      
      finish(raw_data.data, attrs)
    }
    break;
}

/* unleash the dogs... make the AJAX requests in order to the server and when
   they return execute the go() func */
q.await(go);

/* if user requests more years, fetch raw data call for all years and create
   a timeline */
d3.select("#timeline button").on("click", function(){
  d3.json("{{ current_build.data_url('all') }}", function(raw_data){
    
    // go through raw data and set each items nest and id vars properly
    raw_data.data.forEach(function(d){
      d.nest = d[attr_id].substr(0, 2)
      d.id = d[attr_id]
    })
    
    var years = "{{ current_build.year }}"
    var year_interval = 1
    if(years.indexOf(".") > 0){
      years = years.split(".")
      year_interval = parseInt(years[2])
      years = d3.range(parseInt(years[0]), parseInt(years[1])+1, year_interval)
    }
    else {
      years = [parseInt(years)]
    }
    
    viz.data(raw_data.data).time({"solo": years}).draw()
    d3.select("#timeline button").remove()
    
    make_timeline(d3.select("#timeline"), 1995, 2011, years, 1, function(start, end){
      var years = d3.range(start, end, year_interval)
      viz.time({"solo": years}).draw()
      
      if(parent.update_text_table){
        var data_for_table = raw_data.data.filter(function(d){ return years.indexOf(d.year) >= 0 })
        parent.update_text_table(data_for_table, attrs)
      }
    })
    
  })
  d3.event.preventDefault();
})


</script>

{% endblock %}